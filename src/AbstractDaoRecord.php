<?php
/**
 * @package     jelix
 * @subpackage  dao
 *
 * @author      Laurent Jouanneau
 * @contributor Loic Mathaud, Olivier Demah, Sid-Ali Djenadi
 *
 * @copyright   2005-2018 Laurent Jouanneau
 * @copyright   2007 Loic Mathau, 2012 Sid-Ali Djenadid
 * @copyright   2010 Olivier Demah
 *
 * @see        http://www.jelix.org
 * @licence     http://www.gnu.org/licenses/lgpl.html GNU Lesser General Public Licence, see LICENCE file
 */

namespace Jelix\Dao;

/**
 * Base class for all record classes generated by the dao compiler.
 *
 * @package  jelix
 * @subpackage dao
 */
abstract class AbstractDaoRecord implements DaoRecordInterface
{
    /**
     * @var DaoFactoryInterface
     */
    protected $_factory;

    public function setFactory(DaoFactoryInterface $factory)
    {
        $this->_factory = $factory;
    }


    /**
     * @inheritDoc
     */
    abstract public function getDaoName();

    /**
     * Alias for getDaoName, to keep compatibility in Jelix 1.9
     * @return string
     * @deprecated use getDaoName() instead
     */
    public function getSelector()
    {
        return $this->getDaoName();
    }


    /**
     * @inheritDoc
     */
    abstract public function getProperties();

    /**
     * @inheritDoc
     */
    abstract public function getPrimaryKeyNames();

    /**
     * @inheritDoc
     */
    public function check()
    {
        $errors = array();
        foreach ($this->getProperties() as $prop => $infos) {
            $value = $this->{$prop};

            // test required
            if ($infos['required'] && $value === null) {
                $errors[$prop][] = DaoRecordInterface::ERROR_REQUIRED;

                continue;
            }

            switch ($infos['datatype']) {
              case 'varchar':
              case 'string':
                if (!is_string($value) && $value !== null) {
                    $errors[$prop][] = DaoRecordInterface::ERROR_BAD_TYPE;

                    break;
                }
                // test regexp
                if ($infos['regExp'] !== null && preg_match($infos['regExp'], (string)$value) === 0) {
                    $errors[$prop][] = DaoRecordInterface::ERROR_BAD_FORMAT;

                    break;
                }

                //  test maxlength et minlength
                $charset = $this->_factory->getConnection()->getConnectionCharset();
                $len = iconv_strlen((string)$value, $charset);
                if ($infos['maxlength'] !== null && $len > intval($infos['maxlength'])) {
                    $errors[$prop][] = DaoRecordInterface::ERROR_MAXLENGTH;
                }

                if ($infos['minlength'] !== null && $len < intval($infos['minlength'])) {
                    $errors[$prop][] = DaoRecordInterface::ERROR_MINLENGTH;
                }

                break;
            case 'int':
            case 'integer':
            case 'numeric':
            case 'double':
            case 'float':
                if ($value !== null && !is_numeric($value)) {
                    $errors[$prop][] = DaoRecordInterface::ERROR_BAD_TYPE;
                }

                break;
            case 'datetime':
                if (!preg_match('/^(\d{4}-(((0[1,3-9]|1[0-2])-([012][0-9]|3[01]))|((02-([01][0-9]|2[0-9])))) (([01][0-9])|(2[0-3])):[0-5][0-9]:[0-5][0-9])?$/', (string)$value)) {
                    $errors[$prop][] = DaoRecordInterface::ERROR_BAD_FORMAT;
                }

                break;
            case 'time':
                if (!preg_match('/^((([01][0-9])|(2[0-3])):[0-5][0-9]:[0-5][0-9])?$/', (string)$value)) {
                    $errors[$prop][] = DaoRecordInterface::ERROR_BAD_FORMAT;
                }

                break;
            case 'varchardate':
            case 'date':
                if (!preg_match('/^(\d{4}-(((0[1,3-9]|1[0-2])-([012][0-9]|3[01]))|((02-([01][0-9]|2[0-9])))))?$/', (string)$value)) {
                    $errors[$prop][] = DaoRecordInterface::ERROR_BAD_FORMAT;
                }

                break;
            }
        }

        return count($errors) ? $errors : false;
    }

    /**
     * @inheritDoc
     */
    public function setPk(...$pk)
    {
        if (count($pk) == 1 && is_array($pk[0])) {
            $pk = $pk[0];
        }
        $pkf = $this->getPrimaryKeyNames();

        if (count($pk) == 0 || count($pk) != count($pkf)) {
            throw new Exception('(501) Identifier is missing');
        }

        foreach ($pkf as $k => $prop) {
            $this->{$prop} = $pk[$k];
        }

        return true;
    }

    /**
     * @inheritDoc
     */
    public function getPk()
    {
        $pkf = $this->getPrimaryKeyNames();
        if (count($pkf) == 1) {
            return $this->{$pkf[0]};
        }
        $list = array();
        foreach ($pkf as $k => $prop) {
            $list[] = $this->{$prop};
        }

        return $list;
    }

    /**
     * @inheritDoc
     */
    public function save()
    {
        $pkFields = $this->getPrimaryKeyNames();

        if ($this->{$pkFields[0]} == null) {
            return $this->_factory->insert($this);
        }

        return $this->_factory->update($this);
    }
}
